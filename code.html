<!doctype html>
<html class="dark" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <title>Twitch Extension - Task Overlay</title>
    <link
      href="https://cdn.jsdelivr.net/npm/daisyui@4.12.10/dist/full.min.css"
      rel="stylesheet"
      type="text/css"
    />
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800&amp;display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="styles.css" />
    <link rel="stylesheet" href="themes.css" />
    <script>
      // We'll define the EBS_URL globally, but determine its value inside onAuthorized
      // to ensure it's scoped correctly for local testing.
      let EBS_URL = "https://yummy-badgers-dream.loca.lt"; // Default to production

      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.get("local") === "true") {
        document.write('<script src="mock-twitch-ext.js"><\/script>');
      } else {
        document.write(
          '<script src="https://extension-files.twitch.tv/helper/v1/twitch-ext.min.js"><\/script>',
        );
      }
    </script>
    <script id="tailwind-config">
      tailwind.config = {
        darkMode: "class",
        theme: {
          extend: {
            colors: {
              primary: "var(--primary)",
              "background-light": "var(--background-light)",
              "background-dark": "var(--background-dark)",
              "text-light": "var(--text-light)",
              "text-muted": "var(--text-muted)",
              "border-color": "var(--border-color)",
              "vip-glow": "var(--vip-glow)",
              "vip-bg": "var(--vip-bg)",
              subscriber: "var(--subscriber)",
            },
            fontFamily: {
              display: ["Inter"],
            },
            borderRadius: {
              DEFAULT: "0.75rem",
              lg: "1rem",
              xl: "1.5rem",
              full: "9999px",
            },
          },
        },
      };
    </script>
  </head>
  <body class="font-display">
    <div
      class="relative min-h-screen p-4 sm:p-6 lg:p-8 flex items-start justify-end"
    >
      <div class="absolute top-5 left-5 z-10">
        <select id="theme-switcher" class="select select-bordered">
          <option disabled selected>Theme</option>
          <option value="light">Light</option>
          <option value="dark">Dark</option>
          <option value="cupcake">Cupcake</option>
        </select>
      </div>
      <div
        class="w-full max-w-sm bg-background-dark/80 dark:bg-background-dark/80 backdrop-blur-xl rounded-xl border border-border-color/50 shadow-2xl shadow-primary/10 flex flex-col gap-5 text-text-light p-5"
      >
        <div class="flex flex-col gap-2">
          <div class="flex justify-between items-baseline">
            <p class="text-base font-bold leading-normal text-text-light">
              Community Focus
            </p>
            <p
              class="text-sm font-medium leading-normal text-text-muted"
              id="task-counter"
            >
              0/0
            </p>
          </div>
          <div class="h-2.5 w-full bg-black/20 rounded-full overflow-hidden">
            <div
              class="h-full bg-primary rounded-full"
              id="task-progress-bar"
              style="width: 0%"
            ></div>
          </div>
        </div>
        <div class="h-px bg-border-color/50"></div>
        <div>
          <h3
            class="text-lg font-extrabold leading-tight tracking-[-0.015em] text-text-light mb-3"
          >
            Streamer Tasks
          </h3>
          <div id="streamer-tasks" class="flex flex-col">
            <!-- Streamer tasks will be dynamically inserted here -->
          </div>
        </div>
        <div>
          <h3
            class="text-lg font-extrabold leading-tight tracking-[-0.015em] text-text-light mb-3"
          >
            Viewer Tasks
          </h3>
          <div
            id="viewer-tasks"
            class="flex flex-col max-h-[20rem] overflow-y-auto space-y-1 pr-1"
          >
            <!-- Viewer tasks will be dynamically inserted here -->
          </div>
        </div>
        <div>
          <h3
            class="text-lg font-extrabold leading-tight tracking-[-0.015em] text-text-light mb-3"
          >
            Bonus Goals
          </h3>
          <div
            class="flex flex-col items-center justify-center py-6 px-4 text-center bg-black/20 rounded-xl"
          >
            <span class="material-symbols-outlined text-4xl text-text-muted">
              checklist
            </span>
            <p class="text-sm font-medium text-text-muted mt-1">
              No bonus goals yet.
            </p>
          </div>
        </div>
      </div>
    </div>
    <script>
      const twitch = window.Twitch.ext;
      const streamerTasksDiv = document.getElementById("streamer-tasks");
      const viewerTasksDiv = document.getElementById("viewer-tasks");

      let authToken = null;
      let userId = null;
      let opaqueUserId = null;
      let decodedRole = null;
      let isPolling = false;
      let abortController = null;
      let timeoutId = null;

      /**
       * Starts the polling mechanism to fetch tasks from the EBS.
       * If polling is already active, this function does nothing.
       */
      function startPolling() {
        if (isPolling) return;
        isPolling = true;
        abortController = new AbortController();
        fetchTasks();
      }

      /**
       * Stops the polling mechanism.
       * This will abort any in-flight requests and clear any pending timeouts.
       */
      function stopPolling() {
        isPolling = false;
        if (abortController) {
          abortController.abort();
          abortController = null;
        }
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
      }

      /**
       * Twitch onAuthorized callback.
       * This is called when the extension is authorized by Twitch.
       * @param {object} auth - The Twitch authorization object.
       */
      twitch.onAuthorized(async (auth) => {
        console.log("Twitch authorization successful!");
        authToken = auth.token;
        userId = auth.userId;

        // Set EBS_URL based on 'local' and 'ebs' params for testing
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get("local") === "true") {
          if (urlParams.get("ebs") === "notion") {
            EBS_URL = "http://localhost:8081"; // Point to the real Notion EBS
          } else {
            EBS_URL = "http://localhost:8082"; // Default to the mock EBS
          }
        }

        // Decode JWT payload locally to extract opaque_user_id and role so we can
        // decide whether the current viewer may toggle a task checkbox.
        try {
          const payloadBase64 = auth.token.split(".")[1];
          const payloadJson = atob(
            payloadBase64.replace(/-/g, "+").replace(/_/g, "/"),
          );
          const payload = JSON.parse(decodeURIComponent(escape(payloadJson)));
          opaqueUserId = payload.opaque_user_id || payload.user_id || null;
          decodedRole = payload.role || null;
        } catch (err) {
          console.warn("Could not decode JWT payload locally:", err);
        }

        startPolling();
      });

      /**
       * Twitch onVisibilityChanged callback.
       * This is called when the extension's visibility changes.
       * @param {boolean} isVisible - True if the extension is visible, false otherwise.
       */
      twitch.onVisibilityChanged((isVisible) => {
        if (isVisible) {
          startPolling();
        } else {
          stopPolling();
        }
      });

      /**
       * Marks the current viewer's approved task as completed (or not).
       * @param {boolean} isComplete - True to mark the task as complete, false otherwise.
       * @returns {Promise<boolean>} - True if the operation was successful, false otherwise.
       */
      async function markMyTaskComplete(isComplete) {
        if (!authToken) return false;
        try {
          const resp = await fetch(`${EBS_URL}/tasks/me/complete`, {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${authToken}`,
            },
            body: JSON.stringify({ completed: isComplete }),
          });
          if (!resp.ok) {
            const body = await resp.json().catch(() => ({}));
            console.warn("Failed to mark my task complete:", resp.status, body);
            return false;
          }
          return true;
        } catch (err) {
          console.error("Error marking my task complete:", err);
          return false;
        }
      }

      /**
       * Marks a specific page as complete by a moderator or broadcaster.
       * @param {string} pageId - The ID of the page to mark as complete.
       * @param {boolean} isComplete - True to mark the task as complete, false otherwise.
       * @returns {Promise<boolean>} - True if the operation was successful, false otherwise.
       */
      async function markPageCompleteAsMod(pageId, isComplete) {
        if (!authToken) return false;
        try {
          const resp = await fetch(`${EBS_URL}/tasks/${pageId}/complete`, {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${authToken}`,
            },
            body: JSON.stringify({ completed: isComplete }),
          });
          if (!resp.ok) {
            const body = await resp.json().catch(() => ({}));
            console.warn(
              "Failed to mark page complete as mod:",
              resp.status,
              body,
            );
            return false;
          }
          return true;
        } catch (err) {
          console.error("Error marking page complete as mod:", err);
          return false;
        }
      }

      /**
       * Handles the change event for viewer task checkboxes.
       * If the current viewer owns the task, it calls the /tasks/me/complete endpoint.
       * If the user is a moderator/broadcaster, it calls the moderator endpoint.
       * Otherwise, it reverts the checkbox and shows an alert.
       * @param {Event} event - The checkbox change event.
       * @param {string} pageId - The ID of the page associated with the task.
       * @param {string} submitterOpaque - The opaque user ID of the task submitter.
       */
      async function onViewerCheckboxChange(event, pageId, submitterOpaque) {
        const checked = event.target.checked;
        // Allow the owner to mark their own approved task complete
        if (
          opaqueUserId &&
          submitterOpaque &&
          opaqueUserId === submitterOpaque
        ) {
          const ok = await markMyTaskComplete(checked);
          if (!ok) {
            // revert UI change
            event.target.checked = !checked;
          } else {
            // refresh to pick up any changes
            await fetchTasks();
          }
          return;
        }

        // Allow moderators/broadcaster to mark any page complete
        if (decodedRole === "broadcaster" || decodedRole === "moderator") {
          const ok = await markPageCompleteAsMod(pageId, checked);
          if (!ok) event.target.checked = !checked;
          else await fetchTasks();
          return;
        }

        // Otherwise, disallow marking other users' tasks
        alert("You can only mark your own tasks as complete.");
        event.target.checked = !checked;
      }

      /**
       * Fetches tasks from the EBS and updates the UI.
       * If polling is disabled or auth token is not available, this function does nothing.
       * It also handles aborting the request if polling is stopped.
       */
      async function fetchTasks() {
        if (!authToken || !isPolling) {
          return;
        }

        abortController = new AbortController();
        const signal = abortController.signal;

        try {
          const response = await fetch(`${EBS_URL}/tasks`, {
            method: "GET",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${authToken}`,
            },
            signal,
          });

          if (!response.ok) {
            throw new Error(
              `Failed to fetch tasks: ${response.status} ${response.statusText}`,
            );
          }

          const data = await response.json();

          updateTaskCounter(data.streamerTasks, data.viewerTasks);
          renderStreamerTasks(data.streamerTasks);
          renderViewerTasks(data.viewerTasks);
        } catch (error) {
          if (error.name !== "AbortError") {
            console.error("Error fetching tasks:", error);
            const errorMessage =
              "<p class='text-text-muted'>Could not load tasks. Please try again later.</p>";
            streamerTasksDiv.innerHTML = errorMessage;
            viewerTasksDiv.innerHTML = errorMessage;
          }
        } finally {
          if (isPolling) {
            timeoutId = setTimeout(fetchTasks, 10000);
          }
        }
      }

      /**
       * Updates the task counter and progress bar based on the fetched tasks.
       * @param {Array} streamerTasks - The list of streamer tasks.
       * @param {Array} viewerTasks - The list of viewer tasks.
       */
      function updateTaskCounter(streamerTasks, viewerTasks) {
        const allTasks = [...streamerTasks, ...viewerTasks];
        const completedTasks = allTasks.filter((task) => task.completed).length;
        const totalTasks = allTasks.length;

        const counterEl = document.getElementById("task-counter");
        const progressBarEl = document.getElementById("task-progress-bar");

        if (totalTasks > 0) {
          counterEl.textContent = `${completedTasks}/${totalTasks}`;
          progressBarEl.style.width = `${(completedTasks / totalTasks) * 100}%`;
        } else {
          counterEl.textContent = "0/0";
          progressBarEl.style.width = "0%";
        }
      }

      /**
       * Renders the streamer tasks in the UI.
       * @param {Array} tasks - The list of streamer tasks to render.
       */
      function renderStreamerTasks(tasks) {
        streamerTasksDiv.innerHTML = ""; // Clear existing tasks
        if (tasks.length === 0) {
          const p = document.createElement("p");
          p.textContent = "No streamer tasks yet.";
          streamerTasksDiv.appendChild(p);
          return;
        }
        tasks.forEach((task) => {
          const el = document.createElement("label");
          el.className =
            "flex items-center gap-4 py-1.5 px-2 cursor-pointer group bg-black/20 rounded-lg";

          const input = document.createElement("input");
          input.type = "checkbox";
          input.onchange = fetchTasks;
          input.className =
            "h-6 w-6 shrink-0 rounded-lg border-border-color border-2 bg-transparent text-primary checked:bg-primary checked:border-primary focus:ring-2 focus:ring-primary/50 focus:ring-offset-2 focus:ring-offset-background-dark transition-all duration-200";
          if (task.completed) {
            input.checked = true;
          }

          const p = document.createElement("p");
          p.className =
            "text-base font-medium leading-normal text-text-light group-hover:text-primary transition-colors";
          p.textContent = task.title;

          el.appendChild(input);
          el.appendChild(p);
          streamerTasksDiv.appendChild(el);
        });
      }

      /**
       * Renders the viewer tasks in the UI.
       * @param {Array} tasks - The list of viewer tasks to render.
       */
      function renderViewerTasks(tasks) {
        viewerTasksDiv.innerHTML = ""; // Clear existing tasks
        if (tasks.length === 0) {
          const p = document.createElement("p");
          p.textContent = "No viewer tasks yet.";
          viewerTasksDiv.appendChild(p);
          return;
        }
        // Sort tasks by role priority: VIP > Moderator > Subscriber > Viewer
        const rolePriority = {
          VIP: 1,
          Moderator: 2,
          SubscriberT3: 3,
          SubscriberT2: 4,
          SubscriberT1: 5,
          Viewer: 6,
        };
        tasks.sort((a, b) => {
          const priorityA = rolePriority[a.role] || 100;
          const priorityB = rolePriority[b.role] || 100;
          return priorityA - priorityB;
        });

        tasks.forEach((task) => {
          const el = document.createElement("label");
          el.htmlFor = `viewer-task-${task.id}`;

          let iconEl = null;
          let titleClass = "text-text-light";
          let containerClass = "bg-black/20";

          switch (task.role) {
            case "VIP":
              containerClass = "bg-vip-bg vip-task";
              titleClass = "text-vip-glow font-bold";
              iconEl = document.createElement("span");
              iconEl.className =
                "material-symbols-outlined text-3xl text-vip-glow";
              iconEl.textContent = "workspace_premium";
              break;
            case "Moderator":
              // Assuming a moderator style might exist or be added
              titleClass = "text-primary font-bold";
              iconEl = document.createElement("span");
              iconEl.className =
                "material-symbols-outlined text-2xl text-primary";
              iconEl.textContent = "shield";
              break;
            case "SubscriberT1":
            case "SubscriberT2":
            case "SubscriberT3":
              containerClass = "bg-black/20";
              titleClass = "text-subscriber";
              iconEl = document.createElement("span");
              iconEl.className =
                "material-symbols-outlined text-2xl text-subscriber";
              iconEl.textContent = "star";
              break;
          }

          // Apply a disabled style for rejected or completed tasks
          if (task.status === "Rejected" || task.completed) {
            el.classList.add("opacity-50", "line-through");
          }

          el.className = `relative flex items-center gap-4 py-1.5 px-2 group rounded-lg cursor-pointer ${containerClass}`;

          const div1 = document.createElement("div");
          div1.className = "flex-shrink-0";

          const input = document.createElement("input");
          input.type = "checkbox";
          input.onchange = (event) =>
            onViewerCheckboxChange(event, task.id, task.submitter);
          input.className =
            "h-6 w-6 shrink-0 rounded-lg border-border-color border-2 bg-transparent text-primary checked:bg-primary checked:border-primary focus:ring-2 focus:ring-primary/50 focus:ring-offset-2 focus:ring-offset-background-dark transition-all duration-200 peer";
          input.id = `viewer-task-${task.id}`;
          if (task.completed) {
            input.checked = true;
          }
          div1.appendChild(input);

          const div2 = document.createElement("div");
          div2.className = "flex flex-col justify-center flex-1";

          const spanTitle = document.createElement("span");
          spanTitle.className = `text-base font-medium leading-normal ${titleClass} group-hover:text-primary transition-colors`;
          spanTitle.textContent = task.title;

          const pSubmitter = document.createElement("p");
          pSubmitter.className =
            "text-sm font-normal leading-normal text-text-muted";
          pSubmitter.textContent = `by @${task.submitter}`;

          div2.appendChild(spanTitle);
          div2.appendChild(pSubmitter);

          el.appendChild(div1);
          el.appendChild(div2);
          if (iconEl) {
            el.appendChild(iconEl);
          }

          viewerTasksDiv.appendChild(el);
        });
      }

      twitch.onContext((context, changed) => {
        // console.log('Context changed:', context);
      });

      const themeSwitcher = document.getElementById("theme-switcher");
      themeSwitcher.addEventListener("change", (event) => {
        document.querySelector("html").setAttribute("data-theme", event.target.value);
      });
    </script>
  </body>
</html>
